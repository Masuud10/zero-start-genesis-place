import { supabase } from '@/integrations/supabase/client';
import jsPDF from 'jspdf';
import 'jspdf-autotable';
import * as XLSX from 'xlsx';
import { format } from 'date-fns';

// Enhanced Report Data Interface
export interface EnhancedReportData {
  id: string;
  title: string;
  generatedAt: string;
  schoolInfo: SchoolInfo;
  content: Record<string, unknown>;
  generatedBy: string;
  role: string;
  filters?: ReportFilters;
  summary: Record<string, unknown>;
}

export interface SchoolInfo {
  id?: string;
  name: string;
  logo?: string;
  address?: string;
  phone?: string;
  email?: string;
}

export interface ReportFilters {
  dateRange?: { from?: Date; to?: Date };
  classId?: string;
  studentId?: string;
  term?: string;
  academicYear?: string;
}

export interface ExportOptions {
  format: 'pdf' | 'excel';
  includeCharts?: boolean;
  includeTables?: boolean;
  branding?: boolean;
}

export interface ReportGenerationOptions {
  reportType: string;
  filters?: ReportFilters;
  exportOptions?: ExportOptions;
}

export class EnhancedReportService {
  // Enhanced data validation with detailed error reporting
  private static validateReportData(data: unknown): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    if (!data) {
      errors.push('Report data is null or undefined');
      return { isValid: false, errors };
    }
    
    if (typeof data !== 'object') {
      errors.push('Report data must be an object');
      return { isValid: false, errors };
    }
    
    const dataObj = data as Record<string, unknown>;
    
    // Check required fields
    if (!dataObj.title || typeof dataObj.title !== 'string') {
      errors.push('Report title is required and must be a string');
    }
    
    if (!dataObj.generatedAt || typeof dataObj.generatedAt !== 'string') {
      errors.push('Generation timestamp is required and must be a string');
    }
    
    if (!dataObj.generatedBy || typeof dataObj.generatedBy !== 'string') {
      errors.push('Generated by information is required and must be a string');
    }
    
    if (!dataObj.role || typeof dataObj.role !== 'string') {
      errors.push('User role is required and must be a string');
    }
    
    if (!dataObj.content || typeof dataObj.content !== 'object') {
      errors.push('Report content is required and must be an object');
    }
    
    if (!dataObj.schoolInfo || typeof dataObj.schoolInfo !== 'object') {
      errors.push('School information is required and must be an object');
    }
    
    return { isValid: errors.length === 0, errors };
  }

  private static prepareReportData(rawData: unknown): EnhancedReportData {
    const validation = this.validateReportData(rawData);
    if (!validation.isValid) {
      throw new Error(`Invalid report data: ${validation.errors.join(', ')}`);
    }

    const dataObj = rawData as EnhancedReportData;
    
    // Ensure content is properly structured
    const cleanedContent = this.cleanContentData(dataObj.content);
    
    // Calculate summary statistics
    const summary = this.calculateSummaryStatistics(cleanedContent);
    
    // Validate that we have meaningful data
    const hasData = Object.values(cleanedContent).some(data => 
      Array.isArray(data) && data.length > 0
    );
    
    if (!hasData) {
      throw new Error('No meaningful data available for report generation');
    }

    return {
      ...dataObj,
      content: cleanedContent,
      summary,
      id: dataObj.id || `report-${Date.now()}`,
      generatedAt: dataObj.generatedAt || new Date().toISOString()
    };
  }

  private static cleanContentData(content: Record<string, unknown>): Record<string, unknown> {
    const cleaned: Record<string, unknown> = {};
    
    Object.keys(content).forEach(key => {
      const value = content[key];
      
      if (Array.isArray(value)) {
        // Filter out null/undefined values and ensure objects have required properties
        const filteredArray = value.filter(item => {
          if (item === null || item === undefined) return false;
          if (typeof item === 'object') {
            // Ensure object has at least one meaningful property
            return Object.keys(item).length > 0;
          }
          return true;
        });
        
        if (filteredArray.length > 0) {
          cleaned[key] = filteredArray;
        }
      } else if (value && typeof value === 'object') {
        cleaned[key] = value;
      }
    });

    return cleaned;
  }

  private static calculateSummaryStatistics(content: Record<string, unknown>): Record<string, unknown> {
    const summary: Record<string, unknown> = {};

    // Schools summary
    if (content.schools && Array.isArray(content.schools)) {
      summary.totalSchools = content.schools.length;
      summary.activeSchools = content.schools.filter((s: Record<string, unknown>) => 
        s.status === 'active' || s.is_active === true
      ).length;
      summary.totalStudents = content.schools.reduce((sum: number, s: Record<string, unknown>) => 
        sum + (Number(s.student_count) || Number(s.max_students) || 0), 0
      );
    }

    // Users summary
    if (content.users && Array.isArray(content.users)) {
      summary.totalUsers = content.users.length;
      summary.activeUsers = content.users.filter((u: Record<string, unknown>) => 
        u.status === 'active' || u.is_active === true
      ).length;
    }

    // Financial summary
    if (content.fees && Array.isArray(content.fees)) {
      const totalFees = content.fees.reduce((sum: number, f: Record<string, unknown>) => 
        sum + (Number(f.amount) || 0), 0
      );
      const totalPaid = content.fees.reduce((sum: number, f: Record<string, unknown>) => 
        sum + (Number(f.paid_amount) || 0), 0
      );
      summary.totalFees = totalFees;
      summary.totalPaid = totalPaid;
      summary.outstandingFees = totalFees - totalPaid;
      summary.collectionRate = totalFees > 0 ? ((totalPaid / totalFees) * 100).toFixed(1) : 0;
    }

    // Grades summary
    if (content.grades && Array.isArray(content.grades)) {
      const validGrades = content.grades.filter((g: Record<string, unknown>) => {
        const percentage = Number(g.percentage) || Number(g.grade_percentage);
        return !isNaN(percentage) && percentage >= 0 && percentage <= 100;
      });
      
      if (validGrades.length > 0) {
        const avgPercentage = validGrades.reduce((sum: number, g: Record<string, unknown>) => 
          sum + (Number(g.percentage) || Number(g.grade_percentage) || 0), 0
        ) / validGrades.length;
        summary.averageGrade = avgPercentage.toFixed(1);
        summary.totalGrades = validGrades.length;
      }
    }

    // Attendance summary
    if (content.attendance && Array.isArray(content.attendance)) {
      const presentCount = content.attendance.filter((a: Record<string, unknown>) => 
        a.status === 'present' || a.attendance_status === 'present'
      ).length;
      summary.totalAttendance = content.attendance.length;
      summary.presentCount = presentCount;
      summary.attendanceRate = content.attendance.length > 0 ? 
        ((presentCount / content.attendance.length) * 100).toFixed(1) : 0;
    }

    // Transactions summary
    if (content.transactions && Array.isArray(content.transactions)) {
      const totalAmount = content.transactions.reduce((sum: number, t: Record<string, unknown>) => 
        sum + (Number(t.amount) || 0), 0
      );
      summary.totalTransactions = content.transactions.length;
      summary.totalAmount = totalAmount;
    }

    return summary;
  }

  // Enhanced PDF Generation with better error handling and validation
  static async generatePDF(reportData: EnhancedReportData, options: ExportOptions = { format: 'pdf' }): Promise<void> {
    try {
      console.log('ðŸ”„ Starting PDF generation for:', reportData.title);
      
      const preparedData = this.prepareReportData(reportData);
      const doc = new jsPDF('p', 'mm', 'a4');
      
      // Add header with school branding
      const yPosition = this.addEnhancedHeader(doc, preparedData);
      
      // Add report metadata
      let currentY = this.addReportMetadata(doc, preparedData, yPosition);
      
      // Add summary section
      currentY = this.addSummarySection(doc, preparedData, currentY);
      
      // Add content sections based on data availability
      currentY = this.addContentSections(doc, preparedData, currentY);
      
      // Add footer
      this.addEnhancedFooter(doc, preparedData);
      
      // Save the PDF
      const fileName = this.generateFileName(preparedData.title, 'pdf');
      doc.save(fileName);
      
      console.log(`âœ… PDF report generated successfully: ${fileName}`);
    } catch (error) {
      console.error('âŒ PDF generation error:', error);
      throw new Error(`PDF Generation Failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private static addEnhancedHeader(doc: jsPDF, data: EnhancedReportData): number {
    // Header background with gradient effect
    doc.setFillColor(25, 118, 210);
    doc.rect(0, 0, 210, 40, 'F');
    
    // Subtle gradient effect
    doc.setFillColor(13, 71, 161);
    doc.rect(0, 0, 210, 8, 'F');

    // EduFam branding
    doc.setFontSize(24);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(255, 255, 255);
    doc.text('EduFam', 20, 22);
    
    // Tagline
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text('Educational Technology Platform', 20, 28);

    // Report title
    doc.setFontSize(18);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(25, 118, 210);
    doc.text(data.title, 20, 45);

    // School info
    if (data.schoolInfo) {
      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(90, 90, 90);
      doc.text(data.schoolInfo.name, 20, 55);
    }

    return 65; // Return starting Y position for content
  }

  private static addReportMetadata(doc: jsPDF, data: EnhancedReportData, yPosition: number): number {
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(100, 100, 100);
    
    let currentY = yPosition;
    
    // Generation info
    doc.text(`Generated on: ${format(new Date(data.generatedAt), 'PPP \'at\' p')}`, 20, currentY);
    currentY += 6;
    doc.text(`Generated by: ${data.generatedBy} (${data.role.replace('_', ' ')})`, 20, currentY);
    currentY += 6;
    
    // Filters info if available
    if (data.filters) {
      const filterTexts: string[] = [];
      if (data.filters.dateRange?.from) {
        filterTexts.push(`From: ${format(data.filters.dateRange.from, 'PPP')}`);
      }
      if (data.filters.dateRange?.to) {
        filterTexts.push(`To: ${format(data.filters.dateRange.to, 'PPP')}`);
      }
      if (data.filters.classId) {
        filterTexts.push(`Class: ${data.filters.classId}`);
      }
      if (data.filters.studentId) {
        filterTexts.push(`Student: ${data.filters.studentId}`);
      }
      
      if (filterTexts.length > 0) {
        doc.text(`Filters: ${filterTexts.join(', ')}`, 20, currentY);
        currentY += 6;
      }
    }
    
    // Divider
    doc.setDrawColor(200, 200, 200);
    doc.line(20, currentY + 2, 190, currentY + 2);
    
    return currentY + 10;
  }

  private static addSummarySection(doc: jsPDF, data: EnhancedReportData, yPosition: number): number {
    if (!data.summary || Object.keys(data.summary).length === 0) {
      return yPosition;
    }
    
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(25, 118, 210);
    doc.text('Summary Statistics', 20, yPosition);
    
    let currentY = yPosition + 8;
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(60, 60, 60);
    
    Object.entries(data.summary).forEach(([key, value]) => {
      const label = key.replace(/([A-Z])/g, ' $1').replace(/^\w/, c => c.toUpperCase());
      const displayValue = typeof value === 'number' ? 
        (key.toLowerCase().includes('rate') || key.toLowerCase().includes('percentage') ? 
          `${value}%` : value.toLocaleString()) : 
        String(value);
      
      doc.text(`${label}: ${displayValue}`, 20, currentY);
      currentY += 5;
    });
    
    // Divider
    doc.setDrawColor(200, 200, 200);
    doc.line(20, currentY + 2, 190, currentY + 2);
    
    return currentY + 10;
  }

  private static addContentSections(doc: jsPDF, data: EnhancedReportData, yPosition: number): number {
    let currentY = yPosition;
    
    // Add each content section
    Object.entries(data.content).forEach(([key, contentData]) => {
      if (Array.isArray(contentData) && contentData.length > 0) {
        currentY = this.addContentTable(doc, key, contentData, currentY);
      }
    });
    
    return currentY;
  }

  private static addContentTable(doc: jsPDF, sectionName: string, data: any[], yPosition: number): number {
    const pageHeight = doc.internal.pageSize.height;
    
    // Check if we need a new page
    if (yPosition > pageHeight - 50) {
      doc.addPage();
      yPosition = 20;
    }
    
    // Section header
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(25, 118, 210);
    doc.text(sectionName.replace(/([A-Z])/g, ' $1').replace(/^\w/, c => c.toUpperCase()), 20, yPosition);
    
    yPosition += 8;
    
    // Create table data
    if (data.length > 0) {
      const headers = Object.keys(data[0]);
      const tableData = data.slice(0, 20).map(row => 
        headers.map(header => {
          const value = row[header];
          if (value === null || value === undefined) return 'N/A';
          if (typeof value === 'object') return JSON.stringify(value);
          return String(value);
        })
      );
      
      // Use autoTable for better table formatting
      (doc as any).autoTable({
        head: [headers],
        body: tableData,
        startY: yPosition,
        theme: 'grid',
        headStyles: { 
          fillColor: [25, 118, 210],
          textColor: 255,
          fontSize: 10,
          fontStyle: 'bold'
        },
        bodyStyles: { 
          fontSize: 8,
          textColor: [60, 60, 60]
        },
        alternateRowStyles: { 
          fillColor: [248, 249, 250] 
        },
        margin: { left: 20, right: 20 }
      });
      
      yPosition = (doc as any).lastAutoTable.finalY + 10;
    }
    
    return yPosition;
  }

  private static addEnhancedFooter(doc: jsPDF, data: EnhancedReportData): void {
    const pageHeight = doc.internal.pageSize.height;
    
    doc.setFontSize(8);
    doc.setFont('helvetica', 'italic');
    doc.setTextColor(100, 100, 100);
    
    doc.text('Powered by EduFam Education Management System', 20, pageHeight - 15);
    doc.text(`Generated on ${format(new Date(), 'MMM dd, yyyy HH:mm')}`, 20, pageHeight - 10);
    doc.text(`Report ID: ${data.id}`, 20, pageHeight - 5);
  }

  // Enhanced Excel Generation
  static async generateExcel(reportData: EnhancedReportData, options: ExportOptions = { format: 'excel' }): Promise<void> {
    try {
      console.log('ðŸ”„ Starting Excel generation for:', reportData.title);
      
      const preparedData = this.prepareReportData(reportData);
      const workbook = XLSX.utils.book_new();
      
      // Create summary sheet
      const summarySheet = this.createSummarySheet(preparedData);
      XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');
      
      // Create data sheets
      Object.entries(preparedData.content).forEach(([key, data]) => {
        if (Array.isArray(data) && data.length > 0) {
          const sheet = this.createDataSheet(key, data);
          XLSX.utils.book_append_sheet(workbook, sheet, key.charAt(0).toUpperCase() + key.slice(1));
        }
      });
      
      // Save the file
      const fileName = this.generateFileName(preparedData.title, 'xlsx');
      XLSX.writeFile(workbook, fileName);
      
      console.log(`âœ… Excel report generated successfully: ${fileName}`);
    } catch (error) {
      console.error('âŒ Excel generation error:', error);
      throw new Error(`Excel Generation Failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private static createSummarySheet(data: EnhancedReportData): XLSX.WorkSheet {
    const summaryData = [
      ['Report Summary'],
      [''],
      ['Title', data.title],
      ['Generated At', format(new Date(data.generatedAt), 'PPP \'at\' p')],
      ['Generated By', data.generatedBy],
      ['Role', data.role],
      ['School', data.schoolInfo?.name || 'N/A'],
      [''],
      ['Summary Statistics'],
      ['Metric', 'Value']
    ];
    
    Object.entries(data.summary).forEach(([key, value]) => {
      const label = key.replace(/([A-Z])/g, ' $1').replace(/^\w/, c => c.toUpperCase());
      summaryData.push([label, String(value)]);
    });
    
    return XLSX.utils.aoa_to_sheet(summaryData);
  }

  private static createDataSheet(sheetName: string, data: any[]): XLSX.WorkSheet {
    if (data.length === 0) {
      return XLSX.utils.aoa_to_sheet([['No data available']]);
    }
    
    const headers = Object.keys(data[0]);
    const sheetData = [
      headers,
      ...data.map(row => 
        headers.map(header => {
          const value = row[header];
          if (value === null || value === undefined) return 'N/A';
          if (typeof value === 'object') return JSON.stringify(value);
          return String(value);
        })
      )
    ];
    
    return XLSX.utils.aoa_to_sheet(sheetData);
  }

  private static generateFileName(title: string, extension: string): string {
    const cleanTitle = title.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_');
    const timestamp = format(new Date(), 'yyyy-MM-dd_HH-mm');
    return `${cleanTitle}_${timestamp}.${extension}`;
  }

  // Unified export method
  static async exportReport(reportData: EnhancedReportData, options: ExportOptions): Promise<void> {
    if (options.format === 'pdf') {
      await this.generatePDF(reportData, options);
    } else {
      await this.generateExcel(reportData, options);
    }
  }

  // Role-based data fetching methods
  static async fetchRoleBasedData(userRole: string, schoolId?: string, filters?: ReportFilters): Promise<Record<string, unknown>> {
    const content: Record<string, unknown> = {};
    
    try {
      switch (userRole) {
        case 'edufam_admin':
          // System-wide data
          content.schools = await this.fetchSchoolsData();
          content.users = await this.fetchUsersData();
          content.transactions = await this.fetchTransactionsData(filters);
          break;
          
        case 'principal':
        case 'school_owner':
          // School-specific data
          if (!schoolId) throw new Error('School ID required for principal/school owner reports');
          content.students = await this.fetchStudentsData(schoolId);
          content.grades = await this.fetchGradesData(schoolId, filters);
          content.attendance = await this.fetchAttendanceData(schoolId, filters);
          content.fees = await this.fetchFeesData(schoolId, filters);
          content.transactions = await this.fetchTransactionsData(filters, schoolId);
          break;
          
        case 'teacher':
          // Teacher-specific data
          if (!schoolId) throw new Error('School ID required for teacher reports');
          content.grades = await this.fetchGradesData(schoolId, filters);
          content.attendance = await this.fetchAttendanceData(schoolId, filters);
          content.students = await this.fetchStudentsData(schoolId);
          break;
          
        case 'finance_officer':
          // Financial data
          if (!schoolId) throw new Error('School ID required for finance officer reports');
          content.fees = await this.fetchFeesData(schoolId, filters);
          content.transactions = await this.fetchTransactionsData(filters, schoolId);
          content.mpesaTransactions = await this.fetchMpesaTransactionsData(schoolId, filters);
          break;
          
        case 'parent':
          // Parent-specific data
          if (!filters?.studentId) throw new Error('Student ID required for parent reports');
          content.grades = await this.fetchGradesData(schoolId, filters);
          content.attendance = await this.fetchAttendanceData(schoolId, filters);
          break;
          
        default:
          throw new Error(`Unsupported user role: ${userRole}`);
      }
      
      return content;
    } catch (error) {
      console.error('Error fetching role-based data:', error);
      throw error;
    }
  }

  // Data fetching helper methods
  private static async fetchSchoolsData(): Promise<any[]> {
    const { data, error } = await supabase
      .from('schools')
      .select('*')
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data || [];
  }

  private static async fetchUsersData(schoolId?: string): Promise<any[]> {
    let query = supabase
      .from('profiles')
      .select('*')
      .order('created_at', { ascending: false });
    
    if (schoolId) {
      query = query.eq('school_id', schoolId);
    }
    
    const { data, error } = await query;
    if (error) throw error;
    return data || [];
  }

  private static async fetchStudentsData(schoolId: string): Promise<any[]> {
    const { data, error } = await supabase
      .from('students')
      .select('*')
      .eq('school_id', schoolId)
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data || [];
  }

  private static async fetchGradesData(schoolId: string, filters?: ReportFilters): Promise<any[]> {
    let query = supabase
      .from('grades')
      .select('*')
      .eq('school_id', schoolId);
    
    if (filters?.classId) {
      query = query.eq('class_id', filters.classId);
    }
    
    if (filters?.studentId) {
      query = query.eq('student_id', filters.studentId);
    }
    
    const { data, error } = await query.order('created_at', { ascending: false });
    if (error) throw error;
    return data || [];
  }

  private static async fetchAttendanceData(schoolId: string, filters?: ReportFilters): Promise<any[]> {
    let query = supabase
      .from('attendance')
      .select('*')
      .eq('school_id', schoolId);
    
    if (filters?.classId) {
      query = query.eq('class_id', filters.classId);
    }
    
    if (filters?.studentId) {
      query = query.eq('student_id', filters.studentId);
    }
    
    if (filters?.dateRange?.from) {
      query = query.gte('date', filters.dateRange.from.toISOString().split('T')[0]);
    }
    
    if (filters?.dateRange?.to) {
      query = query.lte('date', filters.dateRange.to.toISOString().split('T')[0]);
    }
    
    const { data, error } = await query.order('date', { ascending: false });
    if (error) throw error;
    return data || [];
  }

  private static async fetchFeesData(schoolId: string, filters?: ReportFilters): Promise<any[]> {
    let query = supabase
      .from('fees')
      .select('*')
      .eq('school_id', schoolId);
    
    if (filters?.classId) {
      query = query.eq('class_id', filters.classId);
    }
    
    if (filters?.studentId) {
      query = query.eq('student_id', filters.studentId);
    }
    
    const { data, error } = await query.order('created_at', { ascending: false });
    if (error) throw error;
    return data || [];
  }

  private static async fetchTransactionsData(filters?: ReportFilters, schoolId?: string): Promise<any[]> {
    let query = supabase
      .from('financial_transactions')
      .select('*');
    
    if (schoolId) {
      query = query.eq('school_id', schoolId);
    }
    
    if (filters?.dateRange?.from) {
      query = query.gte('created_at', filters.dateRange.from.toISOString());
    }
    
    if (filters?.dateRange?.to) {
      query = query.lte('created_at', filters.dateRange.to.toISOString());
    }
    
    const { data, error } = await query.order('created_at', { ascending: false });
    if (error) throw error;
    return data || [];
  }

  private static async fetchMpesaTransactionsData(schoolId: string, filters?: ReportFilters): Promise<any[]> {
    let query = supabase
      .from('mpesa_transactions')
      .select('*')
      .eq('school_id', schoolId);
    
    if (filters?.dateRange?.from) {
      query = query.gte('transaction_date', filters.dateRange.from.toISOString());
    }
    
    if (filters?.dateRange?.to) {
      query = query.lte('transaction_date', filters.dateRange.to.toISOString());
    }
    
    const { data, error } = await query.order('transaction_date', { ascending: false });
    if (error) throw error;
    return data || [];
  }
} 